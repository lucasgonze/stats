#!/usr/bin/perl

########################################
# stats: calculate all the standard features of a list of numbers.
# This includes the maximum, mean, median, minimum, standard
# deviation, count, and sum.  
#
# Caveat: code is designed for maintainability, not speed or memory
# conservation.
#
# Changelog:
#
# June 22: add graph generator.  move loose code to subroutines.
# June 19: fix min/max/median for float inputs.  Added "item count" to
# outputs.
# May 14: remove mode, since it was busted, fixing it would take
# longer than I want to spend, and mode of any one number instead of a
# range of numbers is rather useless.  fix median, which was very broken.
# May 13, 2003: created changelog
#
# Permanent home of this code on the web:
# http://gonze.com/stats/
#
# Contact:
# Lucas Gonze <lucas@gonze.com>
#
########################################

use strict;

# ugly workaround for emacs indentation bug -- cperl-mode can't handle a
# dollar sign at the end of a regex, so put the character in a var and
# reference the var .
my $dollar = "\$";

# globals
my @numbers;
my $cnt;

##########
# input

sub parse_input {

    while(<STDIN>){
	chomp();
	
	# trim leading and trailing whitespace
	s/(^\s*)(.*)(\s*$dollar)/$2/g;
	
	# trim trailing CR caused by windows-unix conversion 
	s/(.*)(\r$)/$1/g;
	
	# skip comments and blanks
	if ( /(\#)(.*)/ || /^$/ ) {
	    next;
	}
	
	push(@numbers, $_ + 0);
    }
    
# median and min/max code need the array to be sorted
    my @sorted = sort {$a <=> $b} (@numbers);
    @numbers = @sorted;

    $cnt = $#numbers+1;
    if ( $cnt < 1 ) {
	print "No input\n";
	exit(1);
    }
}

##########
# average

sub get_sum_and_average {
    my $sum = 0;
    for my $number (@numbers) {
	$sum += $number;
    }
    return( $sum, $sum/$cnt );
}

##########
# median

sub get_median(){
  my $median;
  
  my $isOdd = $cnt % 2;
  if( $isOdd ){
    $median = $numbers[ $#numbers/2 ];
  } else {
    $median = ($numbers[ $#numbers/2 ] + $numbers[($#numbers/2)+1] ) /2;
  }
  
    return($median);
}

##########
# standard deviation

sub get_stddev {
  my( $average ) = @_;
  my $stddev = 0;
  if ($cnt < 2) {                 # Only 1 number?
    $stddev = "UNDEFINED";
  } else {
    for my $number (@numbers) { 
      $stddev = $stddev + ($number - $average) ** 2;
    }
    $stddev = sqrt($stddev / ($cnt+1));
  }
  return($stddev);
}

##########
# min and max

sub get_minmax {
  my $min = $numbers[0];
  my $max = $numbers[$#numbers];
  return($min,$max);
}

##########
# histogram.  items are on the X axis, counts are on the Y axis.

sub min {
    my($a, $b) = @_;
    if( $a < $b ){
	return($a);
    } else {
	return($b);
    }
}

sub gen_histogram {
  my ($max,$sum) = @_;
  my $ySize = 10;
  my $xSize = 60;
  my $sizeOfDenormXAxis = $max+1;
  my $sizeOfDenormYAxis = $max+1;
  my $sizeOfNormYAxis = min($ySize,$sizeOfDenormYAxis);
  my $sizeOfNormXAxis = min($xSize,$sizeOfDenormXAxis);
  my @arr;
  my $ret = "";

  my $yNormalizationFactor = $sizeOfNormYAxis/$sizeOfDenormYAxis;
  my $xNormalizationFactor = $sizeOfNormXAxis/$sizeOfDenormXAxis;

  # calculate Y values as the count of each item
  foreach( @numbers ){
    my $normX = $_ * $xNormalizationFactor;
    $arr[$normX]++;
  }
 
  # normalize Y values so that they fit within the graph
  foreach( @arr ){
    $_ = $_ * $yNormalizationFactor;
  }

  $ret = "";

# todo: left padding.  basically, want to center the results.  so if
# there are fewer X entries than the size of the normalized X axis,
# add a space of padding for each of (the difference/ 2).

  my $padding = "       "; 
  my $haveANonBlankLine = 0;
  for( my $i=$sizeOfNormYAxis-1; $i>-1; $i-- ){
    my $str = $padding;
    for( my $j=0; $j<$#arr+1; $j++){
      if( $i+1 > $arr[$j] && $i <= $arr[$j] ){
	$str .= ".";
	$haveANonBlankLine = 1;
      } else {
	$str .= " ";
      }
    }
    if( $haveANonBlankLine ){
      $ret .= "$str\n";
    }
  }

  return($ret);
}

##########
# output

sub draw_output {
  my( $max, $median, $min, $average, $stddev, $sum, $cnt, $histogram )=@_;
print <<EOF;
             maximum: $max
              median: $median
             minimum: $min

             average: $average
  standard deviation: $stddev
                 sum: $sum
          item count: $cnt

           histogram:
$histogram
EOF
}

###########
# main

parse_input();

my ($sum, $average) = get_sum_and_average();
my $median = get_median();
my $stddev = get_stddev($average);
my ($min, $max) = get_minmax();
my $histogram = gen_histogram($max+1, $sum);

draw_output( $max, $median, $min, $average, $stddev, $sum, $cnt, $histogram);
